# vim: set noexpandtab ts=4 sw=4 :

snippet     funcname
	`cfi#get_func_name()`${0}

snippet find_first
	def find_first(list, predicate):
		return next((e for e in list if predicate(e)), None)${0}

snippet open_file
alias with_open_file
	with open(${1:#:input_file_name}, 'r', encoding='utf-8') as ${2:tmp_file}:
		${3:#:input_file_content} = $2.read()
	${0}

snippet class
	class ${1:#:class name}:
		def __init__(self, ${0}):

snippet stdin_readline
abbr input speed up tech
	input = sys.stdin.readline
	line = input()${0}

snippet stdin_readlines
	lines = sys.stdin.readlines()${0}

snippet for_range
	for ${2:i} in range(${1:#: 0 ~ n-1}):
		${0}

snippet init_list
	[None] * ${1:#:N}${0}
snippet init_list2
	[[None] * ${2:#:N2} for _ in range(${1:#:N1})]${0}

snippet write_file
	def write_file(file_name, text, flag='w'):
		with open(file_name, flag) as file:
			file.write(text)
			file.truncate()${0}

snippet read_file
	def read_file(file_name, flag='r')
		with open(file_name, flag) as file:
			return file.read(${0})

snippet argparse_example
alias cmdparse_example
	import argparse

	parser = argparse.ArgumentParser()
	parser.add_argument('-o', '--output-filepath', default='')
	parser.add_argument('-v', '--verbose', action='store_true')
	parser.add_argument('required-arg')
	parser.add_argument('args', nargs='*') # any length of args is ok

	args, extra_args = parser.parse_known_args()
	# args.output_filepath
	# args.verbose
	# args.required_arg
	# args.args
	${0}

snippet self
	self.${0}

snippet from
	from ${1:#: specificated name} import ${0:#: package name}

snippet mean_def_np
	def mean(self):
		mean = np.mean(self.vec, axis=0)
		return mean${0}

snippet mean_np
	${0:#:output} = np.mean(${1:#:input}, axis=0)

snippet exit
	sys.exit(${0})

snippet abspath_of_script_file
abbr abspath of script path # required: import pathlib
	script_abspath = pathlib.Path(__file__).resolve().parent${0}

snippet relpath_of_os_path
	os.path.relpath(${1:#:target filepath}, start=${0:#:base filepath})

snippet pathjoin
	os.path.join(${1:#:path}, ${0:#:path})

snippet urlencode
abbr {'spam': 1, 'eggs': 2, 'bacon': 0}
	import urllib.parse
	urllib.parse.urlencode(${0:#:dict})

snippet urlunquote
abbr e.g. '%E3%81%82' -> 'あ'
	import urllib.parse
	urllib.parse.unquote(${0})
snippet urlquote
abbr e.g. 'あ' -> '%E3%81%82'
	import urllib.parse
	urllib.parse.quote(${0})

snippet decode_uft_8
	decode("utf-8")${0}

snippet getenv
	os.getenv(${1:#:key}, ${0:#:default value})

snippet list_expand
alias tiple_expand
	*${0:#:list name}

snippet dict_expand
	**${0:#:dict name}
snippet dict_remove
	del ${1:#:dict}${0:#:val}

snippet urllib3_proxy_support
abbr urllib3 doesn't use http_proxy env
	option = {'': ''}
	http_proxy = os.getenv("http_proxy")
	http = urllib3.ProxyManager(http_proxy, **option) if http_proxy else urllib3.PoolManager(**option)${0}

# NOTE: order: printf < print_with_end < printf_
snippet printf_
	print("${1:#:message}".format(${0}))
snippet printf_with_end
	print("${1:#:message}".format(${2}), end="${0}")

snippet print_with_end
	print("${1:#:message}", end="${0}")

snippet printf_to_stderr
alias stderr
	print("${1:#:message}".format(${0}), file=sys.stderr)

snippet argv
	sys.argv${0}

snippet pprint
	pprint.pprint(${0})
snippet pformat
	pprint.pformat(${0})

snippet time
	time.time()${0}

snippet deepcopy
	copy.deepcopy(${0})
snippet list_copy_for_simple_type
alias copy_list_for_simple_type
abbr if you want copy recursive refs use deepcopy
	list(${0:#:list})


snippet stopwatch
alias calctime
	since = time.time()
	${0}
	time_elapsed = time.time() - since
	print('{:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))

snippet basename_of_os.path
	os.path.basename(${0})
snippet join_of_os.path
	os.path.join(${1},${0})
snippet exists_of_os.path
	os.path.exists(${0})

snippet listdir_of_os
	os.listdir(${0})
snippet makedirs_of_os
alias mkdir
	os.makedirs(${0}, exist_ok=True)

snippet subprocess.check_output
	subprocess.check_output(${0:#:["ls", "."]}).decode("utf8")

snippet json_from_file
	def read_jsonfile(filepath):
		import json
		with open(filepath, 'r', encoding='utf-8') as f:
			json_dict = json.loads(f.read())
			return json_dict${0}

snippet main
	def main():
		${0}

	if __name__ == '__main__':
		main()

snippet args
alias argv
abbr argv list
	sys.argv${0}

snippet argc
alias argn
abbr # of argv list
	len(sys.argv)${0}

snippet time_day_range
abbr end is not contained
	def daterange(start, end):
		for days in range((end - start).days):
			yield start + datetime.timedelta(days)

	${0}
	start = datetime.datetime.strptime('201801', '%Y%m')
	end   = datetime.datetime.strptime('201802', '%Y%m')
	print(*daterange(start, end), sep='\n')

snippet print_iter_with_type
	print(list(${0:#: iter obj}))

snippet print_iter
	print(*${0:#: iter obj}, sep='\n')

snippet is_pipe
	if not sys.stdin.isatty():
		${0}

snippet clipboard
	text = pyperclip.paste()
	pyperclip.copy(text)${0}

snippet variable_arguments_function
	def ${1:#:func name}(*${2:#:variable arguments list name}):
		${0}

snippet for_enumerate
alias enumerate_for
	for (${1:i}, ${2:v}) in enumerate(${3:#:list}):
		${0}

snippet for_zip
alias zip_for
	for (${1:e1}, ${2:e2}) in zip(${3:#:list1},${4:#:list2}):
		${0}

snippet list_append
alias append_list
abbr if you want to just concat list, use extend!
	${1:#:base list}.append(${0:#:elements})

snippet list_extend
alias extend_list
	${1:#:base list}.extend(${0:#:elements})

snippet unittest_for_only_script
	import unittest

	class Test${1:#:class name}(unittest.TestCase):
		def setUp(self):
			pass
		def test_${2:#:method name}(self):
			self.assertTrue(True)
		def tearDown(self):
			pass
		def fun_not_run(self):
			pass # no run

	if __name__ == "__main__":
		unittest.main()${0}

snippet unittest_in_main_file
	import unittest

	class Test${1:#:class name}(unittest.TestCase):
		def setUp(self):
			pass
		def test_${2:#:method name}(self):
			self.assertTrue(True)
		def tearDown(self):
			pass
		def fun_not_run(self):
			pass # no run${0}

snippet flatten
abbr [["a", "b"], ["c", "d"]] -> ["a", "b", "c", "d"]
	${0:#:dst list} = [ flatten for inner in ${1:#:src list} for flatten in inner ]

snippet stdout_steal
alias contextlib_redirect_stdout
	from contextlib import redirect_stdout
	string_io = io.StringIO()
	with redirect_stdout(string_io):
		${0}
	${1:#:output} = string_io.getvalue()

snippet this_month
	this_month = datetime.date(datetime.date.today().year, datetime.date.today().month, 1).strftime('%Y-%m-%d')${0}

snippet dict2object
	class Struct:
		def __init__(self, **entries):
		self.__dict__.update(entries)
	${0:#:object var name} = Struct(**${1:#:dict var name})

snippet arg_parse_wrapper
	args, _ = parser.parse_known_args_wrapper(args=${1:#:args var name (None:command line options)})${0}

snippet heredoc_indent_ng
	${1:#:heredoc} = """\
		${0}
	"""

snippet heredoc_indent_ok
	import textwrap
	msg = textwrap.dedent("""\
		${0}
	""")

snippet strip_functions
	strip_left = (lambda text, prefix: text if not text.startswith(prefix) else text[len(prefix):])
	strip_right = (lambda text, suffix: text if not text.endswith(suffix) else text[:len(text) - len(suffix)])
	strip = (lambda text, prefix, suffix: strip_right(strip_left(text, prefix), suffix))
	${0}

snippet regexp_example
	m = re.search(r"${1:#: pattern (group1)}", ${2:#:input})
	if m:
		${0:m.group(1)}

snippet decorator
abbr use @func_name before function
	def ${1:#:func name}(func):
		def wrapper(*args, **kwargs):
			${2:#: pre process}
			func(*args, **kwargs)
			${0:#: post process}
		return wrapper

snippet dirname_os_path
	os.path.dirname(${0})
snippet baseame_os_path
	os.path.basename(${0})

snippet expand_filepath
abbr this can exapnd ~
	os.path.expanduser('${0}')

snippet list_function_for_each_example
	pathes = list(map(lambda x: os.path.join('.', x), p.glob('*.pch')))${0}

snippet get_parent_pathes
	def get_parent_pathes(filepath):
		dirpath = filepath
		l = []
		while True:
			dirpath = os.path.dirname(dirpath)
			l += [dirpath]
			if dirpath == '/':
				break
		return l${0}

snippet any_in_list
	any(${1:#:target} in x for x in ${2:#:list})${0}

snippet dict_merge_itself
alias merge_dict_itself
	${1:#:target}.update(${2:#:data})${0}
snippet dict_merge_new
alias merge_dict_new
	dict(${1:#:a}, **${2:#:b})${0}

alias dict_safe_access
	${1:#:dict}.get(${2:#:key})${0}
alias dict_with_default_value
	${1:#:dict}.get(${2:#:key}, ${3:#:default value})${0}
alias dict_force_default_value
abbr None and so on -> defualt value
	${1:#:dict}.get(${2:#:key}) or ${3:#:default value}${0}

alias sleep
abbr import time
	time.sleep(${1:#:sec})${0}

alias thread
abbr import threading
	th = threading.Thread(target=${1:#:func}, args=(${2:#:arg1},))
	th.start()
	th.join()

alias map_list
	${1:#:list} = list(map(lambda e: ${0}, $1))
