# wrap command
snippet wcout
options word
        `{ x -> feedkeys("\<C-o>0\<C-o>\"_".(col('.')-len('wcout'))."x\<C-o>13\<Right>", 'n') == 0 ? x:x}('std::cout << '.substitute(getline('.'), '^\s*\|\s*wcout$', '', 'g').' << std::endl;')`

snippet wcerr
options word
        `{ x -> feedkeys("\<C-o>0\<C-o>\"_".(col('.')-len('wcerr'))."x\<C-o>13\<Right>", 'n') == 0 ? x:x}('std::cout << '.substitute(getline('.'), '^\s*\|\s*wcerr$', '', 'g').' << std::endl;')`

snippet wclog
options word
        `{ x -> feedkeys("\<C-o>0\<C-o>\"_".(col('.')-len('wclog'))."x\<C-o>13\<Right>", 'n') == 0 ? x:x}('std::cout << '.substitute(getline('.'), '^\s*\|\s*wclog$', '', 'g').' << std::endl;')`

snippet wif
options word
        `{ x -> feedkeys("\<C-o>0\<C-o>\"_".(col('.')-len('wif'))."x\<C-o>A\<Left>", 'n') == 0 ? x:x}('if ('.substitute(getline('.'), '^\s*\|\s*wif$', '', 'g').')')`

snippet contains
alias find_string
abbr !=: found, ==: not found
  (${1:str}.find(${2:keyword}) != std::string::npos)

snippet cast_dynamic
abbr for class
  dynamic_cast<${1:# Type}>(${2:TARGET})${0}
snippet cast_static
abbr for not pointer
  static_cast<${1:# Type}>(${2:TARGET})${0}
snippet cast_reinterpret
abbr for pointer
  reinterpret_cast<${1:# Type}>(${2:TARGET})${0}
snippet cast_const
abbr for const cast
  const_cast<${1:# Type}>(${2:TARGET})${0}
snippet void_pointer_to_rvalue_cast
  auto &${0} == static_cast<$2&>(*reinterpret_cast<${2:#type}*>(${1:# pointer}));

snippet debug_print
options head
abbr << __func__ << ...
  std::cerr << __func__ << ": " << ${1:#:msg} << " (" __FILE__ ":" << __LINE__ << ')' << std::endl;${0}

snippet to_bool
alias bool
  ((${0:bool value})?"true":"false")

# NOTE: pp is too short to select
snippet pppp
alias ppp
  #include "cxx-prettyprint/prettyprint.hpp" // https://github.com/louisdx/cxx-prettyprint
snippet streampp
  #include "umaumaxcpp/streampp.hpp" // FORBIDDEN_COMMIT_MAGIC_KEYWORD${0}

snippet std
alias s
  std::

snippet stdcout
alias cout
  std::cout << ${0} << std::endl;

snippet stdcerr
alias cerr
  std::cerr << ${0} << std::endl;

snippet stdclog
alias clog
  std::clog << ${0} << std::endl;

# [iq1snippets/cpp\.snip at master Â· koturn/iq1snippets]( https://github.com/koturn/iq1snippets/blob/master/cpp11/cpp.snip )
# for vector etc...
snippet cout_all
  std::copy(std::begin(${1}), std::end($1), std::ostream_iterator<const decltype($1)::value_type&>(std::cout, ${2:" "}));

snippet precision
  std::fixed << std::setprecision(${1}) << ${0}

snippet setfill
  std::setw(${1:#:n}) << std::setfill(${2:'0'}) << ${0}

snippet fstream
  std::${1:fstream} ${2:fs}(${3:#:filename}${4:, std::ios::binary});
  if (!$2.is_open()) {
    ${5:std\:\:cerr << "Failed to open\: " << $3 << std\:\:endl;}
  }
  ${0}

snippet sleep
  std::this_thread::sleep_for(std::chrono::${1:milliseconds}(${2:1000}));

snippet numeric_limits
  std::numeric_limits<${1:int}>::${0}()

snippet foreach_iterator
  for (std::${1:vector}<${2}>::iterator ${3:itr} = ${4}.begin(); $3 != $4.end(); ++$3) {
    ${0}
  }

snippet string
abbr std::string <string>
  std::string ${0}

snippet vector
abbr std::vector<T> <vector>
  std::vector<${1:int}> ${0}

snippet vector2d
abbr std::vector<std::vector<T> > <vector>
  std::vector<std::vector<${1:int}> > ${2:#:varname}(${3:#:height}, std::vector<$1>(${4:#:width}))

snippet random
  std::${1:mt19937} ${2:rnd}((std::random_device())())

snippet thread
  std::thread ${1:#:name}([${2:&}]{
    ${0}
  });

snippet async
  auto ${1:#:name} = std::async(std::launch::${2:async}, [${3:&}]{
    ${0}
  });

snippet unused
  (void)

snippet for_auto
  for (auto&& ${1:e} : ${2:#:container}) {
    ${0}
  }

snippet try
  try {
    ${0}
  } catch (${1:const std::exception&} ${2:e}) {
    ${3:std::cerr << $2.what() << std::endl;}
  }

# <algorithm>
snippet for_each
abbr std::for_each <algorithm>
  std::for_each(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      ${0}
    });

snippet all_of
abbr std::all_of <algorithm>
  std::all_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet none_of
abbr std::none_of <algorithm>
  std::none_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet any_of
abbr std::any_of <algorithm>
  std::any_of(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet sort
abbr std::sort <algorithm>
  std::sort(std::begin(${1}), std::end($1))

snippet sort_lambda
abbr std::sort <algorithm>
  std::sort(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
      return ${0:#:x < y};
    });

snippet sort_stable
abbr std::stable_sort <algorithm>
  std::stable_sort(std::begin(${1}), std::end($1))

snippet sort_stable_lmabda
abbr std::stable_sort <algorithm>
  std::stable_sort(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& x, const decltype($1)::value_type& y) {
      return ${0:#:x < y};
    });

snippet min_element
abbr std::min_element <algorithm>
  std::min_element(std::begin(${1}), std::end($1))

snippet max_element
abbr std::max_element <algorithm>
  std::max_element(std::begin(${1}), std::end($1))

snippet find
abbr std::find <algorithm>
  std::find(std::begin(${1}), std::end($1), ${2:#:value})

snippet find_if
abbr std::find_if <algorithm>
  std::find_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet remove
abbr std::remove <algorithm>
  std::remove(std::begin(${1}), std::end($1), ${2:#:value})

snippet remove_if
abbr std::remove_if <algorithm>
  std::remove_if(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:e}) {
      return ${0};
    });

snippet remove_erase
  ${1}.erase(std::remove(std::begin($1), std::end($1), ${2:#:value}), std::end($1));

snippet remove_erase_if
  ${1}.erase(
    std::remove_if(
      std::begin($1),
      std::end($1),
      [](const decltype($1)::value_type& ${2:e}) {
        return ${0};
      }),
    std::end($1));

snippet unique
abbr std::unique <algorithm>
  std::unique(std::begin(${1}), std::end($1))

snippet unique_lambda
abbr std::unique <algorithm>
  std::unique(
    std::begin(${1}),
    std::end($1),
    [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
      return ${0:#:x == y};
    });

snippet unique_erase
  ${1}.erase(std::unique(std::begin($1), std::end($1)), std::end($1));

snippet unique_erase_lambda
  ${1}.erase(
    std::unique(
      std::begin($1),
      std::end($1),
      [](const decltype($1)::value_type& ${2:x}, const decltype($1)::value_type& ${3:y}) {
        return ${0:#:x == y};
      }),
    std::end($1));

snippet copy
abbr std::copy <algorithm>
  std::copy(std::begin(${1}), std::end($1), std::begin(${2}))

snippet sum
  std::accumulate(std::begin(${1}), std::end($1), ${2:decltype($1)::value_type()})

snippet time_measurement
  auto ${1:start} = std::chrono::system_clock::now();
  ${0};
  auto ${2:elapsed} = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - $1).count();

snippet duration_cast
abbr std::chrono::duration_cast<T>() <chrono>
  std::chrono::duration_cast<std::chrono::${1:milliseconds}>(${2})
snippet shared_void_pointer_cast
alias cast_shared_void_pointer
abbr cast std::shared_ptr<void> to some pointer (also unique pointer)
  (${0:# dst pointer type}*)${1:#smart pointer var name}.get()

snippet lock_guard
  {
    std::lock_guard<decltype($2)> ${1:lock}(${2:#:mutex});
    ${0}
  }

snippet lock_guard_adopt
  {
    std::lock_guard<decltype($2)> ${1:lock}(${2:#:mutex}, std::adopt_lock);
    ${0}
  }

snippet join
  std::ostringstream ${1:oss};
  if (!${2}.empty()) {
    std::copy(std::begin($2), std::prev(std::end($2)), std::ostream_iterator<const decltype($2)::value_type&>($1, ${3:","}));
    $1 << *std::rbegin($2);
  }
  ${0}

snippet join_to_string
  ${1}.empty() ? "" : std::accumulate(
    std::next(std::begin($1)),
    std::end($1),
    std::to_string($1[0]),
    [](const std::string& ${2:acc}, const decltype($1)::value_type& ${3:e}) {
      return $2 + ${4:","} + std::to_string($3);
    })${0}

snippet split
  std::vector<std::string> ${1:tokens};
  std::string::size_type ${2:spos} = 0, ${3:epos}, ${4:delimlen} = sizeof(${5:","}) - 1;
  while (($3 = ${6:#:string}.find_first_of(",", $2)) != std::string::npos) {
    $1.emplace_back($6.substr($2, $3 - $2));
    $2 = $3 + $4;
  }
  $1.emplace_back($6.substr($2));
  ${0}

snippet split_by_char
  std::vector<std::string> ${1:tokens};
  std::istringstream ${2:iss}(${3:#:string});
  for (std::string ${4:token}; std::getline($2, $4, ${5:','});) {
    $1.push_back($4);
  }
  ${0}

snippet regex
  std::regex ${1:#:name}("${2:#:pattern}");

snippet regex_match_loop
  for (std::sregex_iterator ${1:itr} = std::sregex_iterator(std::begin(${2:#:text}), std::end($2), ${3:#:regex}), ${4:end}; $1 != $4; ++$1) {
    ${0}
  }

snippet regex_split_loop
  for (std::sregex_iterator ${1:itr} = std::sregex_iterator(std::begin(${2:#:text}), std::end($2), ${3:#:regex}, -1), ${4:end}; $1 != $4; ++$1) {
    ${0}
  }

snippet regex_replace
  std::regex_replace(${1:#:text}, std::regex("${2:#:pattern}"), "${3:#:after}");

snippet extern_c
  #ifdef __cplusplus
  extern "C" {
  #endif  // __cplusplus

  ${0}

  #ifdef __cplusplus
  }
  #endif  // __cplusplus

snippet if_cpp11
  #if __cplusplus >= 201103L
  ${0}
  #endif  // __cplusplus >= 201103L

snippet if_cpp14
  #if __cplusplus >= 201402L
  ${0}
  #endif  // __cplusplus >= 201402L

snippet if_gcc
  #ifdef __GNUC__
  ${0}
  #endif  // __GNUC__

snippet if_x64
  #if defined(__x86_64__) || defined(_WIN64) || defined(__MINGW64__)
  ${0}
  #endif  // defined(__x86_64__) || defined(_WIN64) || defined(__MINGW64__)

snippet class_template
  template <class T>
  class ${1:#class name} {
   public:
    $1(){};

   private:
    int ${2:#method name}(T xxx);
  };

  template <>
  inline int $1<int>::$2(int xxx) {
    return 0;
  }
  template <>
  inline int $1<char>::$2(char xxx) {
    return 0;
  }

